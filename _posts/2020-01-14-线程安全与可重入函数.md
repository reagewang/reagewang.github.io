---
layout: post
title: "线程安全与可重入函数"
tags: [thread]
comments: true
---

比如我们在一个函数中调用到了一个全局变量NUM用来标记某一东西的数量。学过操作系统的同学都知道，如果我们在修改它的值的时候发生了中断，另一个函数又对他进行了修改，此时该变量的值会出错。这种函数就是线程不安全函数。他是属于没有保护共享变量的线程不安全函数。在单线程时运行毫无问题，但一旦放到多线程中就容易出bug。但如果我们在修改这个全局变量NUM前对他进行加锁，再操作完后再进行解锁。这样即使有两个线程在调用这个函数，其结果也不会出问题。此时，这个函数就是线程安全函数。但他依旧不是可重入函数。因为他不能保证两个函数“同时”运行，必须等待解锁后才能运行。而我们在平时开发中应该尽量编写可重入的函数。 

函数分为线程安全和线程不安全函数。
# 线程安全函数
线程安全的函数可以被多个线程同时调用，即使这些调用都使用到了共享的数据，因为它对共享数据的使用都是序列化，也就是每个序列操作全部完成之前是不可能被别的线程的使用而中断的。
# 线程不安全函数
线程不安全函数主要分为以下四大类：
* 不保护共享变量的函数，函数中访问全局变量和堆。共享变量在多线程中是共享数据比如全局变量和堆，如果不保护共享变量，多线程时会出bug。可以通过同步机制来保护共享数据，比如加锁。
* 保持跨越多个调用的状态的函数，函数中分配，重新分配释放全局资源。与上面第一点基本相同，通过加锁可解决。
* 返回指向静态变量的指针的函数，函数中通过句柄和指针的不直接访问。比如，我们要计算a,b两个变量的和，于是将a，b的指针传入某一个函数，然而此时可能有另一个线程改变了a,b的值，此时在函数中我们通过地址取到的两个数的值已经改变了，所以计算出的结果也就是错的了。
又比如某些函数（如gethostbyname）将计算结果放在静态结构中，并返回一个指向这个结构的指针。在多线程中一个线程调用的结构可能被另一个线程覆盖。可以通过重写函数和加锁拷贝技术来消除。加锁拷贝技术指在每个位置对互斥锁加锁，调用线程不安全函数，动态的为结果分配存储器，拷贝函数返回的结构，然后解锁。
* 调用线程不安全的函数,常见的系统线程不安全函数。
# 可重入函数
可重入是指被多个线程调用时，不会引用任何共享数据。可重入函数比不可重入函数高效，因为不需要同步操作。可重入的方法也能被多个线程同时调用，但是必须是每个调用都只使用自己的数据。因此，线程安全的方法必定是可重入的，但是可重入的方法未必是线程安全的。
## 显式可重入
如果函数所有参数都是传值的，所有数据引用都是本地的自动栈变量，就是显式可重入的。
## 隐式可重入
如果函数参数有指针的，但是是指向非共享数据的指针，就是隐式可重入的。

若一个函数是可重入的，则该函数：
* 不能含有静态（全局）非常量数据。
* 不能返回静态（全局）非常量数据的地址。
* 只能处理由调用者提供的数据。
* 不能依赖于单实例模式资源的锁。
* 不能调用(call)不可重入的函数。

一个类是可重入的，指的是，只要每个线程用的是不同的类的实例。一个类是线程安全的，指的是它的成员方法可以安全的被多个线程同时调用，即使每个线程使用的是相同的类实例。C++类一般情况下都是可重入的，因为类的成员方法一般都只能操作成员数据，每个线程都是通过自己的类实例调用成员方法，不可能存在别的线程调用同一个类实例的方法。