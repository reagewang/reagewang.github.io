---
layout: post
title: "回调函数"
tags: [回调函数]
comments: true
---

1. 回调函数是什么东西？
2. 回调函数怎么开发，怎么使用？
3. 回调函数的作用，应该在什么情况下使用？
 
# 什么是回调函数?
简而言之，回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。`回调函数就是函数指针的一种用法。`

# 为什么要使用回调函数？
因为可以把调用者与被调用者分开。调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件（如返回值为int）的被调用函数。

* 使用回调函数实际上就是在调用某个函数（通常是API函数）时，将自己的一个函数（这个函数为回调函数）的地址作为参数传递给那个函数。而那个函数在需要的时候，利用传递的地址调用回调函数，这时你可以利用这个机会在回调函数中处理消息或完成一定的操作。 
* 回调函数，就是由你自己写的。你需要调用另外一个函数，而这个函数的其中一个参数，就是你的这个回调函数名。这样，系统在必要的时候，就会调用你写的回调函数，这样你就可以在回调函数里完成你要做的事。
* 回调函数是应用程序提供给Windows系统DLL或其它DLL调用的函数，一般用于截获消息、获取系统信息或处理异步事件。应用程序把回调函数的地址指针告诉DLL，而DLL在适当的时候会调用该函数。回调函数必须遵守事先规定好的参数格式和传递方式，否则DLL一调用它就会引起程序或系统的崩溃。通常情况下，回调函数采用标准WindowsAPI的调用方式，即__stdcall，当然，DLL编制者可以自己定义调用方式，但客户程序也必须遵守相同的规定。在__stdcall方式下，函数的参数按从右到左的顺序压入堆栈，除了明确指明是指针或引用外，参数都按值传递，函数返回之前自己负责把参数从堆栈中弹出。

# 例子
```c++
#include <stdio.h>
 
void printWelcome(int len) {
       printf("欢迎欢迎 -- %d/n", len);
}
 
void printGoodbye(int len) {
       printf("送客送客 -- %d/n", len);
}
 
void callback(int times, void (* print)(int)) {
    int i;
    for (i = 0; i < times; ++i)
    {
            print(i);
    }
    printf("/n我不知道你是迎客还是送客!/n/n");
}

void main(void) {
    callback(10, printWelcome);
    callback(10, printGoodbye);
    printWelcome(5);
}
```
我实现了一个很简单的回调函数。上面的代码没有被任何系统函数调用，说明那些东西只是撒撒土迷迷路人眼而已。还有面向对象编程时，用class给封装起来也是掩人耳目，不要被外表所迷惑。

# 回调函数的作用和使用
用过STL的人都知道，在STL中众多算法和程序都用到回调函数，这实现了一种策略。只要任何符合我的标准的函数和计算都可以用我这个公式。你可以实现各种各样的回调函数，只要符合我的格式就能用。就上面的程序来说，你只要函数格式符合callback第二个参数的格式不论你给别人做饭、铺床叠被都可以正常工作。这就是回调的作用，把回调实现留给别人。这是一个用法。

比如我要写一个子模块给你用,来接收远程socket发来的命令.当我接收到命令后,需要调用你的主模块的函数,来进行相应的处理.但是我不知道你要用哪个函数来处理这个命令,我也不知道你的主模块是什么.cpp或者.h,或者说,我根本不用关心你在主模块里怎么处理它,也不应该关心用什么函数处理它.怎么办?

如果想知道回调函数在实际中有什么作用，先假设有这样一种情况，我们要编写一个库，它提供了某些排序算法的实现，如冒泡排序、快速排序、shell排序、shake排序等等，但为使库更加通用，不想在函数中嵌入排序逻辑，而让使用者来实现相应的逻辑；或者，想让库可用于多种数据类型（int、 float、string），此时，该怎么办呢？

回调可用于通知机制，例如，有时要在程序中设置一个计时器，每到一定时间，程序会得到相应的通知，但通知机制的实现者对我们的程序一无所知。而此时，就需有一个特定原型的函数指针，用这个指针来进行回调，来通知我们的程序事件已经发生。实际上，SetTimer() API使用了一个回调函数来通知计时器，而且，万一没有提供回调函数，它还会把一个消息发往程序的消息队列。

# 回调函数中调用类中的非静态成员变量或非静态成员函数
回调函数必须是`静态成员函数`或者`全局函数`来实现回调函数，大概原因是`普通的C++成员函数`都隐含了一个函数参数，即this指针，C++通过传递this指针给成员函数从而实现函数可以访问类的`特定对象`的数据成员。由于this指针的原因，使得一个普通成员函数作为回调函数时就会因为隐含的this指针问题使得函数参数个数不匹配，从而导致回调函数编译失败。

基于上面的理论，如何在类中封装回调函数呢？

回调函数只能是全局函数或者静态成员函数，但是由于全局函数会破坏封装性，所以只能用静态成员函数作为回调函数，这样才能在类中封装回调函数。

但是如果有这样的需求，当触发某一个事件的时候，我想访问类的普通成员函数和普通成员变量，怎么办？首先明确一点，普通的成员函数不能作为回调函数，所以不能在事件触发后直接回调普通成员函数。那么只能有一种办法，当事件触发后，回调类的静态成员函数，然后想办法通过类的静态成员函数访问普通成员函数和普通的成员变量。

*`注意：类的静态成员函数由于没有this指针，是不能直接访问类的普通成员变量的，也不能访问类的普通成员函数。这里说的是想办法。`*

1. 如何让静态函数访问类的非静态成员

声明一静态函数a()，将类实例对象指针做为参数传入
```c++
class A()
{
    static void a(A *pThis); //静态函数
    void b();        //非静态函数
}; 
 
void A::a(A *pThis)
{
    pThis->b(); //静态函数中调用非静态函数
}
```
2. 回调函数中访问非静态成员（这里的回调函数只能是类的静态成员函数）

由于回调函数往往有固定定义，并不接受  A * pThis 参数，如：CALLBACK MyTimerProc(HWND hwnd,UINT uMsg,UINT idEvent,DWORD dwTime);

【解决方案一】不把对象指针作为静态成员函数的参数，而是作为类的静态成员变量。这样在静态成员函数（已经作为回调函数）中也能够直接访问这个对象指针（通过对象指针操作普通成员变量和普通成员函数）。
```c++
class A()
{
  static void a(); //静态回调函数
  void b();  //非静态函数
  static A * pThis;   //静态对象指针
}; 
 
A * A::pThis=NULL;
A::A()   //构造函数中将this指针赋给pThis，使得回调函数能通过pThis指针访问本对象
{
   pThis=this;
}
void A::a()
{
  if (pThis==NULL)
      return;
  pThis->b(); //回调函数中调用非静态函数
}
```
本方案当遇到有多个类实例对象时会有问题。原因是pThis指针只能指向一个对象，所以不能调用不同对象的b()函数，换而言之还是不能够真正的在回调函数中调用普通成员函数。因为普通成员函数的调用必须是有对象为基础的，这里只有一个对象，所以只能调用那一个对象的普通成员函数，很显然这是不会满足条件的。

【解决方案2】：本方案解决多个类实例对象时方案1的问题。用映射表存所有对象地址，每个对象保存自己的ID号。
```c++
class A()
{
  static void a(); //静态回调函数
  void b();  //非静态函数
  int m_ID;  //本对象在列表中的ID号
  static int m_SID;   //静态当前对象ID        (需要时，将m_ID赋值给m_SID以起到调用本对象函数的功能)
  static CAMap m_Map; //静态对象映射表
} 
 
CAMap A::m_Map;
int A::m_SID=0;
 
 
A::A()   //构造函数中将this指针赋给pThis，使得回调函数能通过pThis指针访问本对象
{
  if(m_Map.IsEmpty())
  {
        m_ID=1;
  }
  else
  {
    m_ID=m_Map.GetCount()+1;
  }
 
  m_Map.SetAt( m_ID, this );
}
void A::a()
{
  if (m_Map.IsEmpty())
      return;
  A * pThis=NULL;
  if(m_Map.Lookup(m_SID,pThis))
  {
    pThis->b(); //回调函数中调用非静态函数
  }
}
```
总结：

回调函数是基于C编程的Windows SDK的技术，不是针对C++的，程序员可以将一个C函数直接作为回调函数，但是如果试图直接使用C++的成员函数作为回调函数将发生错误，甚至编译就不能通过。 

普通的C++成员函数都隐含了一个传递函数作为参数，亦即“this”指针，C++通过传递一个指向自身的指针给其成员函数从而实现程序函数可以访问C++的数据成员。这也可以理解为什么C++类的多个实例可以共享成员函数但是确有不同的数据成员。由于this指针的作用，使得将一个CALLBACK型的成员函数作为回调函数安装时就会因为隐含的this指针使得函数参数个数不匹配，从而导致回调函数安装失败。