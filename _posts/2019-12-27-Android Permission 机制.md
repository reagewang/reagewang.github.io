---
layout: post
title: "Android Permission 机制"
tags: [android,permission]
comments: true
---

AndroidManifest.xml里面的sharedUserID能够让不同的apk运行在同一个进程里，分享里面的数据，比如Contacts等，当然这个sharedUserID可以设置成“android.uid.system”就可以运行在系统进程中，有权修改系统数据。

但仅仅有着一个sharedUserID并不能够保证你的apk一定能运行成功，怎么办？

签名啊。如果你有Android的源码就比较方便了，直接把Android.mk里面的LOCAL_CERTIFICATE 赋值为platform就行了。然后mm编辑，就能安装了。因为在安装的时候，PackageManager会检查，如果sharedUserId是system的，它会看这个apk的签名是不是system.crt，如果不是，会报出permission deny的error。而把LOCAL_CERTIFICATE改成platform就等于给APK签名。

进而可以通过这个问题研究一下整个Android permission的机制。

系统的安全机制通过给每个用户分配单独的uid和gid来实现，Android系统中pid代表进程ID，这个是有系统在程序运行时分配的，这一点可以防止地址空间的数据共享，增强内存空间的安全性。对于外部则用到了uid进行封锁。

系统会给于用户进程单独的uid，当然系统也是要运行进程的，比如System，Radio，蓝牙，IO设备。系统中的init.rc文件会详细定义这些文件的权限。Android中对uid的定义是Root最高，其次是system，最低的是app。这是基于Linux系统的结果。

那么在APP里，要对一些进程进行访问，或者接受Broadcast，或者启动Activity、Service都是需要权限的，不能说你的app什么都能做，这也是需要在manifest file中设置的。

比如在startActivity时，如果你start自己apk里的activity，它们会在同一个application下，那么自然也就使用一个uid，start过程自然没有什么问题。如果你需要start别人写的Activity或者service，都需要用到同一个shareUserId才行，因为在ActivityManagerService要启动activity的之前，会首先检查uid，用checkPermission方法，透过binder获得pid和uid，检查你activity的binder的权限，如果你有权限则已，没权限的话就会抛出security exception。至于broadcast，检查则更为严格，会双向的检查发出者和接受者的权限.

## startActivity中的permission检测与UID机制
我们经常在一个activity中去start另一个activity，或者与另一个acitivity的结果进行交互（startActivityForResult）。但有没有想过可能会出现的permission问题呢？如果你遇到了permission denial的Exception，那么你需要读读这篇文章啦。

我们在同一个application内部，可以随意的startActivity from Activity A to Activity B，而官方的文档中说startActivity可能会报NotFoundException，表示被start的Activity不存在。因此，我们很容易忽略另一个可能的Exception，Permission Denial。

当我们在不同的application中，如application A中的Activity去start一个application B中的Activity，也许你什么Exception都不会得到，也可能会直接Force Close掉。因为再Start Activity时，代码是有去检验permission的。

如下情况，可以成功startActivity而不会得到permission denial
1. 同一个application下
2. Uid相同
3. permission匹配
4. 目标Activity的属性Android:exported=”true”
5. 目标Activity具有相应的IntentFilter，存在Action动作或其他过滤器并且没有设置exported=false
6. 启动者的Pid是一个System Server的Pid
7. 启动者的Uid是一个System Uid（Android规定android.system.uid=1000，具有该Uid的application，我们称之为获得Root权限）

如果上述调节，满足一条，一般即可（与其他几条不发生强制设置冲突），否则，将会得到Permission Denial的Exception而导致Force Close。

现在，我来解释一下Uid机制

众所周知，Pid是进程ID，Uid是用户ID，只是Android和计算机不一样，计算机每个用户都具有一个Uid，哪个用户start的程序，这个程序的Uid就是那个那个用户，而Android中每个程序都有一个Uid，默认情况下，Android会给每个程序分配一个普通级别互不相同的Uid，如果用互相调用，只能是Uid相同才行，这就使得共享数据具有了一定安全性，每个软件之间是不能随意获得数据的。而同一个application只有一个Uid，所以application下的Activity之间不存在访问权限的问题。

如果你需要做一个application，将某些服务service，provider或者activity等的数据，共享出来怎么办，三个办法:
1. 完全暴露，这就是android:exported=”true”的作用，而一旦设置了intentFilter之后，exported就默认被设置为true了，除非再强制设为false。当然，对那些没有intentFilter的程序体，它的exported属性默认仍然是false，也就不能共享出去。
2. 权限提示暴露，这就是为什么经常要设置usePermission的原因，如果人家设置了android:permission=”xxx.xxx.xx”那么，你就必须在你的application的Manufest中usepermission xxx.xxx.xx才能访问人家的东西。
3. 私有暴露，假如说一个公司做了两个产品，只想这两个产品之间可互相调用，那么这个时候就必须使用shareUserID将两个软件的Uid强制设置为一样的。这种情况下必须使用具有该公司签名的签名文档才能，如果使用一个系统自带软件的ShareUID，例如Contact，那么无须第三方签名。

这种方式保护了第三方软件公司的利益于数据安全。

当然如果一个activity是由system process跑出来的，那么它就可以横行霸道，任意权限，只是你无法开发一个第三方application具有系统的Pid（系统Pid不固定），但是你完全可以开发一个具有系统Uid的程序，对系统中的所有程序任意访问，只需再Manufest中声明shareUserId为android.system.uid即可，生成的文件也必须经过高权限签名才行，一般不具备这种审核条件的application，google不会提供给你这样的签名文件。当然你是在编译自己的系统的话，想把它作成系统软件程序，只需在Android.mk中声明Certificate:platform则可以了，既采用系统签名。这个系统Uid的获得过程，我们把它叫做获得Root权限的过程。所以很多第三方系统管理软件就是有Root权限的软件，因为他需要对系统有任意访问的权限。那么它的Root签名则需要和编译的系统一致，例如官方的系统得用官方的签名文件，CM的系统就得用CM的签名文件。（这里就不多讲了）