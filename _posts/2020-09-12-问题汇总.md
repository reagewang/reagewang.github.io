---
layout: post
title: "经验总结"
tags: [build, debug]
comments: true
---

经验总结

# 编译通过但打包时提示png图片资源错误
```
FAILURE: Build failed with an exception.
 
What went wrong:
Execution failed for task ':app:mergeReleaseResources'.
java.util.concurrent.ExecutionException: com.android.builder.internal.aapt.v2.Aapt2Exception: Android resource compilation failed
Output:  D:\Gitee\sun\Launcher\app\src\main\res\mipmap-mdpi\tech_ac_statusbar_air_seat_ventilation_left_off.png: error: failed to read PNG signature: file does not start with PNG signature.

原因是图片后缀虽然是png但是图片本身资源不是
```

# 在build lib中的class文件时，没找到其中一个jar文件，这个文件不存在。
```
Error:FAILURE: Build failed with an exception.

* What went wrong:
Could not resolve all files for configuration ':app:debugCompileClasspath'.
> Failed to transform file 'CommonTools.jar' to match attributes {artifactType=processed-jar} using transform IdentityTransform
   > Transform output file D:\Gitee\sun\Launcher\app\libs\CommonTools.jar does not exist.

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.

* Get more help at https://help.gradle.org

BUILD FAILED in 2s

看了下各个libs下的文件，发现确实没有。但是以往build的时候，并没有出现上述问题。仔细想了想，以前build没有出现这个问题，说明这个jar在项目中没有被用到，因为如果有用到，而jar包又确实不存在，肯定会build失败。所以，就想把该jar注释掉试试看build会如何

重新build后，可以build成功

回顾以前，想起来，当初项目用到的一个功能，需要使用第三方的lib，所以使用了上面的jar。 后来，项目中又用到另一个功能，需要使用同一个服务商的另一个lib，这个lib包含了上面lib的功能，所以把原来的删除掉，但是compile files这块还存在没有去掉

结论：新的版本as，至少3.0.1，增加了对编译时使用lib的校验，如果没有找到相应的jar，就会报错。
```

# c++编译错误：invalid new-expression of abstract class type
```
出现这个错误原因是new 了一个抽象类出错，说明父类（接口）中有纯虚函数没有实现。接口里的纯虚函数全部需要实现，这样才能new 子类。
```

# Ubuntu下run格式双击无效
```
要先右键--权限--允许以程序运行
```

# Qt setGeometry时没有移动到指定的位置原因
```
QWindow变更大小时需要reSize重置窗口的大小
```

# Qt Creator 编译警告
```
QML Settings: Failed to initialize QSettings instance. Status code is: 1
QML Settings: The following application identifiers have not been set: QVector("organizationName", "organizationDomain")

解决方法
在main.cpp文件里添加

app.setOrganizationName("Some Company");
app.setOrganizationDomain("somecompany.com");
app.setApplicationName("Amazing Application");
```

# This Template did not Produce a Java Class or an interface
```
找到Android Studio安装目录下的Studio.exe.vmoptions，如果是64位的，就用记事本打开64的这个文件。在末尾添加`-Djdk.util.zip.ensureTrailingSlash=false`保存。重启Android Studio就可以了
```

# Android P 运行JobService时提示 No such service class
```java
// jobId需要唯一
JobInfo.Builder builder = new JobInfo.Builder(jobId, new ComponentName(包名, 类名);
```

# Android studio 编译错误
```
Error:FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':app:preDebugAndroidTestBuild'.
> Conflict with dependency 'com.android.support:support-annotations' in project ':app'. Resolved versions for app (25.3.1) and test app (27.1.1) differ. See https://d.android.com/r/tools/test-apk-dependency-conflicts.html for details.

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.

* Get more help at https://help.gradle.org

BUILD FAILED in 7s

解决方法 1
于 app 的 build.gradle 中， 在 android{...} 里添加如下代码：
configurations.all {
        resolutionStrategy.force 'com.android.support:support-annotations:27.1.1'
    }
同步 build.gradle 文件

解决方法 2
于 app 的 build.gradle 中， 在 android{...} 里，更改一下属性，使其为最近版本号，如下
andorid{
    ...
    defaultConfig {
     compileSdkVersion 27
        defaultConfig {
            ...
            targetSdkVersion 27
            ...
        }
        ...
    }
    ...
}

经验总结:
看报错信息 '.Conflict with dependency 'com.android.support:support-annotations' 说明是依赖冲突，Resolved versions for app (26.1.0) and test app (27.1.1) differ 给出了冲突的版本，之后要么把冲突的地方降级为 (26.1.0)，要么把整个升级为版本 27
```

# Qt加载PNG图片警告
```
libpng warning: iCCP: cHRM chunk does not match sRGB
libpng warning: iCCP: known incorrect sRGB profile
```
```
把要加载的图片用PS中去掉png图像的icc配置文件就可以了
或者用QImage重新加载另存为PNG也可以
```

# 错误 signal 6 - SIGABRT
``` 
free 多次
fclose 多次
```
# 错误 signal 11 - SIGSEGV
```
引用空指针成员
fclose 空指针
```

# qlabel加载图片时图片会造成qlabel的大小产生变化
需要设置setSizePolicy

# linux下双击qt程序无法运行
qt在linux下编译出来的应用程序需要在pro增加QMAKE_LFLAGS += -no-pie，不然双击无法运行

# qsocketnotifier socket notifiers cannot be enabled or disabled from another thread
把udpsocket放到线程里面进行数据处理，udpsocket构造的时候需要指定父类对象this，如m_pUdpSocket = new QUdpSocket(this);不然与UI进行数据信号传递时会报"qsocketnotifier socket notifiers cannot be enabled or disabled from another thread"错误

# QML中绘制动态图像可以采用两种方式
a.在QML中加入Image组件然后给source属性赋值Image地址，此地址由继承QQuickImageProvider的类接口提供，在加载url之前添加继承QQuickImageProvider的类。
形式如下：
QQmlApplicationEngine engine;
engine.addImageProvider(QLatin1String("目录名"), 继承QQuickImageProvider的类对象);
source地址如下：
Image.cache: false
Image.source："image://目录名/id名"

b.继承QQuickPaintedItem
注册该类，qmlRegisterType<继承QQuickPaintedItem的类名>("包名", 1, 0, "在QML中用来表示继承QQuickPaintedItem的类的名字");
实现paint接口，把对图像的绘制放置到paint接口里面实现，类似于QtWidget模式下的painterEvent接口一样。
继承QQuickPaintedItem的类在注册的时候就已经实例化好了，不能把该类放置到另外的类里面做成员变量，不然paint无法被调用

# 回调函数内访问类成员函数
申明静态类指针，指针初始化，类构造时赋值this给静态类指针，即可在回调函数内引用类指针访问类成员函数或成员对象

# QML中Text旋转了之后进行对齐的问题

# 执行./configure报错
1. arm-hisiv400-linux-g++: not found 是因为环境问题
* 查看编译器版本命令“arm-hisiv400-linux-g++ -v”
* 结果：bash: /opt/hisi-linux/x86-arm/arm-hisiv400-linux-g++/target/bin/arm-hisiv400-linux-g++: No such file or directory 说明：gcc编译器找不到，但是编译器确实是安装完成了，输入arm，按两次Tab后也能找到交叉编译gcc文件

2. 交叉编译器虽然安装了，但是交叉编译器的运行缺少库文件，这是因为宿主机是64 位 而交叉编译器是针对32位的开发板制作的。所以要安装对应的32位库。我的linux宿主机是ubuntu 16.04 64位。安装命令：
```
sudo apt install lib32z1-dev
```

3. 安装完成后，再执行“arm-hisiv400-linux-g++ -v”，即可出现gcc的版本信息，表示gcc安装成功。

# Linux下QtCreator加载资源文件编译错误
Linux下加载资源文件区分大小写后缀

# release版本的日志中QMessageLogContext内容为空
原因是：文件信息、行数等信息在Release版本默认舍弃。我们只要在.pro文件定义一个宏
> DEFINES += QT_MESSAGELOGCONTEXT

# watch 指令
> watch -n 10 cat /home/ubuntu/log/qtlog.text
每隔10秒查看日志

# tail 指令
> tail -10 /home/ubuntu/log/qtlog.text
查看倒数10行

# CRT SSH Ubuntu时无法再终端执行GUI程序
CRT开启x11 forwarding
> echo $DISPLAY
> DISPLAY=:0.0 //默认是0.0，实际值看ubuntu显示的 echo $DISPLAY

# Ubuntu下创建Qt程序可以双击执行
QMAKE_LFLAGS += -no-pie

# Ubuntu修改开机进入命令行模式，一次修改永久有效：
```
sudo systemctl set-default multi-user.target 
反馈：
Removed /etc/systemd/system/default.target
Created symlink /etc/systemd/system/default.target->/lib/systemd/system/multi-user.target
```

# Ubuntu修改开机进入图形界面，一次修改永久有效：
```
sudo systemctl set-default graphical.target 
反馈:
Removed /etc/systemd/system/default.target
Created symlink /etc/systemd/system/default.target->/lib/systemd/system/graphical.target
```

# 发布Qt应用可能需要的export信息
```
export SYSQTDIR=/usr/lib/aarch64-linux-gnu
export APPDIR=/home/ubuntu/app/qtapp
export QT_QPA_PLATFORM_PLUGIN_PATH=$SYSQTDIR/qt5/plugins
export QT_QPA_FONTDIR=$APPDIR/fonts
export QT_QPA_PLATFORM=linuxfb:fb=/dev/fb0:size=1920x1080:mmsize=1920x1080:offset=0x0:tty=/dev/tty2
export QT_QPA_PLATFORM='offscreen'
export QT_QPA_EGLFS_FB=/dev/fb0
export LD_LIBRARY_PATH=$SYSQTDIR/lib:$LD_LIBRARY_PATH
export LD_LIBRARY_PATH=$APPDIR/import-lib:$LD_LIBRARY_PATH
```

# Qt添加CMake支持
```
下载CMake并解压
https://cmake.org/download/
tar xvf cmake-3.12.0-rc3.tar.gz

编译并安装CMake
$ cd cmake-3.12.0-rc3/
$ ./bootstrap
$ make -j8
$ sudo make install

配置Qt
Qt-->Tools-->Options-->Build & Run-->CMake-->Add
Name：随意，姑且取cmake-3.12.0-rc3
Path：/home/yong/Downloads/cmake-3.12.0-rc3/bin/cmake，即编译出来的CMake命令的绝对路径。
Qt->Tools->Options->Build & Run->Kits->Desktop(dafault)->CMake Tool
```
# 编译cmake问题
```
Could NOT find OpenSSL, try to set the path to OpenSSL root folder in the system variable OPENSSL_ROOT_DIR (missing: OPENSSL_LIBRARIES OPENSSL_INCLUDE_DIR) 
在 Ubuntu 系统上的解决方法是，在命令行输入如下命令：sudo apt-get install libssl-dev
```

# SecureCRT下的串口不能输入
用secureCRT建了一个串口COM1后，连接上开发板后，可以正确接受和显示串口的输出，但是按键输入无效。
解决方法：
Session Options -> Connection -> Serial -> Flow Control，将原先默认选中的 RTS/CTS取消掉，再重新connect开发板，再次连上后，此时就可以从键盘输入了。

# Source Insight 4 的解决办法
```
单个文件乱码解决办法：菜单栏中【File】 > 【Reload As Encoding...】 > 【Chinese Simplified (GB18030)】 > 选择后，点击load，问题解决！！！
所有文件乱码解决办法：我的理解，在做下面操作的时候关闭所有工程或文件，等设置完后，再把工程或文件加载进来
菜单栏中 【Options】 > 【Preferences】 >File标签中，最下面的“Default encod­ing” ：改成System Default(Windows ANSI)或者Chinese Simplified(GB2312) CP:936，点击确定，问题解决！！！
```

# Qt信号传递值传递和引用传递
同一进程下，值传递会拷贝对象，引用传递不会
跨进程下，如果connect方式为auto，值传递参数和引用传递参数没有区别，都会复制对象，如果为DirectConnection，测试结果和在同一线程中的结果相同

# Ubuntu 定时执行脚本
```
vim /etc/crontab

*/5 *   * * *   root    echo 0 > /sys/class/graphics/fb0/blank 

service cron restart
```
* service cron start /*启动服务*/
* service cron stop /*关闭服务*/
* service cron restart /*重启服务*/
* service cron reload /*重新载入配置*/
* service cron status /*查看crond状态*/ 
  
```
minute   hour   day   month   week  user  command     #顺序：分 时 日 月 周 用户 命令
minute： 表示分钟，可以是从 0 到 59 之间的任何整数。
hour：表示小时，可以是从 0 到 23 之间的任何整数。
day：表示日期，可以是从 1 到 31 之间的任何整数。
month：表示月份，可以是从 1 到 12 之间的任何整数。
week：表示星期几，可以是从 0 到 7 之间的任何整数，这里的 0 或 7 代表星期日。
user：linux的用户身份，例如root，或者其他用户
command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。

星号（*）：代表所有可能的值，例如 month 字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。
逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”
中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”
正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在 minute 字段，表示每十分钟执行一次。
```

# Linux下记录内存信息
```
#include <execinfo.h>
int backtrace(void **buffer, int size);
char **backtrace_symbols(void *const *buffer, int size);
void backtrace_symbols_fd(void *const *buffer, int size, int fd);
```

# 错误: fatal error: bits/libc-header-start.h: No such file or directory
出现这个错误时，这多半是你所编译的项目是在64位机器上生成32位的项目，你需要安装对应的gcc 32位的库；此时检查gcc一定有-m32的存在；
sudo apt-get install gcc-multilib g++-multilib

# Jeston Nano 安装 Qt5
> sudo apt-get install qt5-default qtcreator -y

```
1. 问题：
warning: implicit declaration of function ‘XXX’; did you mean ‘YYY’? [-Wimplicit-function-declaration]
2. 原因：
“XXX”这个函数所在头文件没有添加。
3. 解决：
找到函数“XXX”所在头文件添加到工程中。
4. 举例：
warning: implicit declaration of function ‘usleep’; did you mean ‘fseek’? [-Wimplicit-function-declaration]
只要把  #include <unistd.h> 添加到头文件处，警告就会消失。
```

# QProcess执行echo指令
> /bin/bash -c \"echo 0 > /sys/class/graphics/fb0/blank\"

# 利用qmake生成Makefile文件
1. 装好qmake工具
2. 在源码工程目录下，运行qmake -project 这样会生成一个*.pro文件。
3. 运行qmake -makefile *.pro，生成Makefile文件。